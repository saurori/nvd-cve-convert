package app

import (
	"compress/gzip"
	"encoding/json"
	"encoding/xml"
	"errors"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"runtime"

	"github.com/bcicen/jstream"
	"github.com/mitchellh/mapstructure"

	"github.com/saurori/nvd-cve-convert/pkg/types"
)

type App struct {
	nvdCpeFile string
	nvdCveFile string
	xmlFile    string
}

func NewApp() (*App, error) {
	app := &App{}

	// Parse flags
	flag.StringVar(&app.nvdCpeFile, "cpe-file", "", "path to the NVD CPE JSON Match Feed data file (gzipped). See https://nvd.nist.gov/vuln/data-feeds")
	flag.StringVar(&app.nvdCveFile, "cve-file", "", "path to the NVD CVE JSON Feed data file (gzipped). See https://nvd.nist.gov/vuln/data-feeds")
	flag.StringVar(&app.xmlFile, "xml-file", "", "path to the resulting output XML file")

	flag.Parse()

	if len(app.nvdCpeFile) == 0 {
		return nil, errors.New("-cpe-file is required")
	}
	if len(app.nvdCveFile) == 0 {
		return nil, errors.New("-cve-file is required")
	}
	if len(app.xmlFile) == 0 {
		return nil, errors.New("-xml-file is required")
	}

	return app, nil
}

func (app *App) Run() error {
	jsonData, err := parseJsonFile(app.nvdCveFile)
	if err != nil {
		return fmt.Errorf("failed to parse NVD CVE JSON file: %s", err)
	}

	// Build a map of CPE data that is needed from `nvdcpematch`
	// NOTE: if this takes up too much memory, consider disk-based KV solution
	cpeData := make(map[string]*types.NvdCpeMatch)
	for _, item := range jsonData.CVEItems {
		for i := range item.Configurations.Nodes {
			loadCpeData(&item.Configurations.Nodes[i], cpeData)
		}
	}

	// Fill the map with cpe data from `nvdcpematch` file. This is required for
	// expanding the CPE matches to all product version CPE strings.
	app.cpeMatchIterator(cpeData)

	// Build parent node
	xmlData := types.NvdXML{
		Vuln:           "http://scap.nist.gov/schema/vulnerability/0.4",
		Xmlns:          "http://scap.nist.gov/schema/feed/vulnerability/2.0",
		CpeLang:        "http://cpe.mitre.org/language/2.0",
		ScapCore:       "http://scap.nist.gov/schema/scap-core/0.1",
		Cvss:           "http://scap.nist.gov/schema/cvss-v2/0.2",
		Patch:          "http://scap.nist.gov/schema/patch/0.1",
		Xsi:            "http://www.w3.org/2001/XMLSchema-instance",
		NvdXMLVersion:  "2.0",
		PubDate:        jsonData.CVEDataTimestamp,
		SchemaLocation: "http://scap.nist.gov/schema/patch/0.1 https://scap.nist.gov/schema/nvd/patch_0.1.xsd http://scap.nist.gov/schema/feed/vulnerability/2.0 https://scap.nist.gov/schema/nvd/nvd-cve-feed_2.0.xsd http://scap.nist.gov/schema/scap-core/0.1 https://scap.nist.gov/schema/nvd/scap-core_0.1.xsd",
	}

	// Parse all data entries
	for _, item := range jsonData.CVEItems {
		entry, err := item.ToNvdEntry(cpeData)
		if err != nil {
			return fmt.Errorf("failed to convert CVE %s to Entry: %s", item.Cve.CVEDataMeta.ID, err)
		}
		xmlData.Entry = append(xmlData.Entry, entry)
	}

	// Marshal data to XML
	xmlOut, err := xml.MarshalIndent(xmlData, "", "  ")
	if err != nil {
		return fmt.Errorf("failed to marshal XML data: %s", err)
	}

	// Create the output XML file
	outFile, err := os.Create(app.xmlFile)
	if err != nil {
		return fmt.Errorf("failed to create XML file: %s", err)
	}
	defer outFile.Close()

	// Write XML header
	if _, err := outFile.Write([]byte(xml.Header)); err != nil {
		return fmt.Errorf("failed to write XML data header: %s", err)
	}
	// Write XML data
	if _, err := outFile.Write(xmlOut); err != nil {
		return fmt.Errorf("failed to write XML data: %s", err)
	}
	// Write final new line
	if _, err := outFile.Write([]byte("\n")); err != nil {
		return fmt.Errorf("failed to write XML final line: %s", err)
	}

	// Print memory usage
	printMemUsage()

	return nil
}

// parseJsonFile parses a given NVD gzipped JSON file into `NvdJSON`.
func parseJsonFile(fName string) (*types.NvdJSON, error) {
	f, err := os.Open(fName)
	if err != nil {
		return nil, err
	}
	defer f.Close()

	gzr, err := gzip.NewReader(f)
	if err != nil {
		log.Fatal(err)
	}
	defer gzr.Close()

	raw, err := ioutil.ReadAll(gzr)
	if err != nil {
		return nil, err
	}

	var data types.NvdJSON
	if err := json.Unmarshal(raw, &data); err != nil {
		return nil, err
	}

	return &data, nil
}

// loadCpeData loads cpe strings from a node into the keys of `cpeData` map
func loadCpeData(node *types.NvdConfigurationNode, cpeData map[string]*types.NvdCpeMatch) {
	for _, match := range node.CpeMatch {
		cpeData[match.ToHash()] = nil
	}
	for i := range node.Children {
		loadCpeData(&node.Children[i], cpeData)
	}
}

// cpeMatchIterator stream iterates the NVD `nvdcpematch-1.0.json.gz` file
// and fills the `cpeData` with required data.
func (app *App) cpeMatchIterator(cpeData map[string]*types.NvdCpeMatch) {
	f, err := os.Open(app.nvdCpeFile)
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()

	gzr, err := gzip.NewReader(f)
	if err != nil {
		log.Fatal(err)
	}
	defer gzr.Close()

	decoder := jstream.NewDecoder(gzr, 2)
	for mv := range decoder.Stream() {
		var match types.NvdCpeMatch
		if err := mapstructure.Decode(mv.Value, &match); err != nil {
			log.Fatal(err)
		}

		// Check if this cpe data is needed and add it
		hash := match.ToHash()
		if _, ok := cpeData[hash]; ok {
			cpeData[hash] = &match
		}
	}
}

// PrintMemUsage outputs the current, total and OS memory being used. As well as the number
// of garage collection cycles completed.
// https://golangcode.com/print-the-current-memory-usage/
func printMemUsage() {
	var m runtime.MemStats
	runtime.ReadMemStats(&m)
	// For info on each, see: https://golang.org/pkg/runtime/#MemStats
	out := fmt.Sprintf("Alloc = %v MiB", bToMb(m.Alloc))
	out += fmt.Sprintf("\tTotalAlloc = %v MiB", bToMb(m.TotalAlloc))
	out += fmt.Sprintf("\tSys = %v MiB", bToMb(m.Sys))
	out += fmt.Sprintf("\tNumGC = %v", m.NumGC)
	fmt.Println(out)
}

func bToMb(b uint64) uint64 {
	return b / 1024 / 1024
}
