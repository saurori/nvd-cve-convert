package types

import (
	"fmt"
	"log"
	"strconv"
	"strings"
	"time"

	"github.com/gofrs/uuid"
	"github.com/umisama/go-cpe"
)

type NvdJSON struct {
	CVEDataType         string       `json:"CVE_data_type"`
	CVEDataFormat       string       `json:"CVE_data_format"`
	CVEDataVersion      string       `json:"CVE_data_version"`
	CVEDataNumberOfCVEs string       `json:"CVE_data_numberOfCVEs"`
	CVEDataTimestamp    string       `json:"CVE_data_timestamp"`
	CVEItems            []NvdCveItem `json:"CVE_Items"`
}

type NvdCveItem struct {
	Cve struct {
		DataType    string `json:"data_type"`
		DataFormat  string `json:"data_format"`
		DataVersion string `json:"data_version"`
		CVEDataMeta struct {
			ID       string `json:"ID"`
			ASSIGNER string `json:"ASSIGNER"`
		} `json:"CVE_data_meta"`
		Problemtype struct {
			ProblemtypeData []struct {
				Description []struct {
					Lang  string `json:"lang"`
					Value string `json:"value"`
				} `json:"description"`
			} `json:"problemtype_data"`
		} `json:"problemtype"`
		References struct {
			ReferenceData []struct {
				URL       string   `json:"url"`
				Name      string   `json:"name"`
				Refsource string   `json:"refsource"`
				Tags      []string `json:"tags"`
			} `json:"reference_data"`
		} `json:"references"`
		Description struct {
			DescriptionData []NvdDescriptionDate `json:"description_data"`
		} `json:"description"`
	} `json:"cve"`
	Configurations struct {
		CVEDataVersion string                 `json:"CVE_data_version"`
		Nodes          []NvdConfigurationNode `json:"nodes"`
	} `json:"configurations"`
	Impact           *NvdImpact `json:"impact"`
	PublishedDate    string     `json:"publishedDate"`
	LastModifiedDate string     `json:"lastModifiedDate"`
}

type NvdImpact struct {
	BaseMetricV2 struct {
		CvssV2 struct {
			Version               string  `json:"version"`
			VectorString          string  `json:"vectorString"`
			AccessVector          string  `json:"accessVector"`
			AccessComplexity      string  `json:"accessComplexity"`
			Authentication        string  `json:"authentication"`
			ConfidentialityImpact string  `json:"confidentialityImpact"`
			IntegrityImpact       string  `json:"integrityImpact"`
			AvailabilityImpact    string  `json:"availabilityImpact"`
			BaseScore             float64 `json:"baseScore"`
		} `json:"cvssV2"`
		Severity                string  `json:"severity"`
		ExploitabilityScore     float64 `json:"exploitabilityScore"`
		ImpactScore             float64 `json:"impactScore"`
		ObtainAllPrivilege      bool    `json:"obtainAllPrivilege"`
		ObtainUserPrivilege     bool    `json:"obtainUserPrivilege"`
		ObtainOtherPrivilege    bool    `json:"obtainOtherPrivilege"`
		UserInteractionRequired bool    `json:"userInteractionRequired"`
	} `json:"baseMetricV2"`
}

type NvdDescriptionDate struct {
	Lang  string `json:"lang"`
	Value string `json:"value"`
}

type NvdCpeMatches []NvdCpeMatch

type NvdConfigurationNode struct {
	Operator string                 `json:"operator"`
	CpeMatch NvdCpeMatches          `json:"cpe_match"`
	Negate   bool                   `json:"negate"`
	Children []NvdConfigurationNode `json:"children"`
}

// ToVulnConfig converts a node into a `NvdVulnerableConfiguration` and returns a list of products
func (node NvdConfigurationNode) ToVulnConfig(cpeData map[string]*NvdCpeMatch) (NvdVulnerableConfiguration, []string) {
	const (
		vulnConfigId = "http://nvd.nist.gov/"
	)

	logicalTest, products := node.ToLogicalTest(cpeData)

	cfg := NvdVulnerableConfiguration{
		ID:          vulnConfigId,
		LogicalTest: logicalTest,
	}

	return cfg, products
}

func (node NvdConfigurationNode) ToLogicalTest(cpeData map[string]*NvdCpeMatch) (NvdLogicalTest, []string) {
	var children []NvdLogicalTest
	var childProducts []string
	for _, child := range node.Children {
		c, prods := child.ToLogicalTest(cpeData)
		children = append(children, c)
		childProducts = append(childProducts, prods...)
	}

	factRef, products := node.CpeMatch.ToFactRefs(cpeData)
	products = append(products, childProducts...)

	return NvdLogicalTest{
		Operator:    node.Operator,
		Negate:      strconv.FormatBool(node.Negate),
		FactRef:     factRef,
		LogicalTest: children,
	}, products
}

// ToFactRefs converts NvdCpeMatches into slice of `NvdFactRef` and list of products
func (matches NvdCpeMatches) ToFactRefs(cpeData map[string]*NvdCpeMatch) ([]NvdFactRef, []string) {
	var refs []NvdFactRef
	var products []string
	uniqFactRefs := make(map[string]struct{})

	for _, match := range matches {
		hash := match.ToHash()
		if expandMatch, ok := cpeData[hash]; ok {
			// Add parent
			cpeConv, err := cpe.NewItemFromFormattedString(expandMatch.Cpe23URI)
			if err != nil {
				log.Fatal(fmt.Errorf("failed to parse CPE URI %s : %s", expandMatch.Cpe23URI, err))
			}
			uri := cpeConv.Uri()
			if _, ok := uniqFactRefs[uri]; !ok {
				refs = append(refs, NvdFactRef{Name: uri})
				products = append(products, uri)
			}

			// Add children
			for _, m := range expandMatch.Cpename {
				cpeConvName, err := cpe.NewItemFromFormattedString(m.Cpe23URI)
				if err != nil {
					log.Fatal(fmt.Errorf("failed to parse CPE URI %s : %s", m.Cpe23URI, err))
				}
				nameUri := cpeConvName.Uri()
				if _, ok := uniqFactRefs[nameUri]; !ok {
					refs = append(refs, NvdFactRef{Name: nameUri})
					products = append(products, nameUri)
				}
			}
		} else {
			// TODO: what to do if not found?
			log.Fatal("not found", match)
		}
	}

	return refs, products
}

func (item NvdCveItem) ToNvdEntry(cpeData map[string]*NvdCpeMatch) (*NvdEntry, error) {
	var vulnConfigs []NvdVulnerableConfiguration
	var products []string
	for _, item := range item.Configurations.Nodes {
		vConf, prods := item.ToVulnConfig(cpeData)
		vulnConfigs = append(vulnConfigs, vConf)
		products = append(products, prods...)
	}

	const (
		dateFmtJSON = "2006-01-02T15:04Z"
		dateFmtXML  = "2006-01-02T15:04:05.999-07:00"
		source      = "http://nvd.nist.gov"
		lang        = "en"
	)

	pubDate, err := time.Parse(dateFmtJSON, item.PublishedDate)
	if err != nil {
		return nil, err
	}
	lastMod, err := time.Parse(dateFmtJSON, item.LastModifiedDate)
	if err != nil {
		return nil, err
	}

	var references []NvdReference
	for _, ref := range item.Cve.References.ReferenceData {
		r := NvdReference{
			Lang:          lang,
			ReferenceType: ReferenceTagsToReferenceType(ref.Tags),
			Source:        ref.Refsource,
			Reference: NvdVulnReference{
				Text: ref.Name,
				Href: ref.URL,
				Lang: lang,
			},
		}
		references = append(references, r)
	}

	var cvss *NvdCvss
	if item.Impact.BaseMetricV2.CvssV2.Version != "" {
		cvss = &NvdCvss{
			// NOTE: GeneratedOnDatetime not available in JSON
			BaseMetrics: NvdBaseMetrics{
				Score:                 item.Impact.BaseMetricV2.CvssV2.BaseScore,
				AccessVector:          item.Impact.BaseMetricV2.CvssV2.AccessVector,
				AccessComplexity:      item.Impact.BaseMetricV2.CvssV2.AccessComplexity,
				Authentication:        item.Impact.BaseMetricV2.CvssV2.Authentication,
				ConfidentialityImpact: item.Impact.BaseMetricV2.CvssV2.ConfidentialityImpact,
				IntegrityImpact:       item.Impact.BaseMetricV2.CvssV2.IntegrityImpact,
				AvailabilityImpact:    item.Impact.BaseMetricV2.CvssV2.AvailabilityImpact,
				Source:                source,
			},
		}
	}

	var vulnSoftwareList *NvdVulnerableSoftwareList
	if len(products) > 0 {
		vulnSoftwareList = &NvdVulnerableSoftwareList{Product: products}
	}

	entry := &NvdEntry{
		ID:                      item.Cve.CVEDataMeta.ID,
		VulnerableConfiguration: vulnConfigs,
		VulnerableSoftwareList:  vulnSoftwareList,
		CveID:                   item.Cve.CVEDataMeta.ID,
		PublishedDatetime:       pubDate.Format(dateFmtXML),
		LastModifiedDatetime:    lastMod.Format(dateFmtXML),
		Cvss:                    cvss,
		SecurityProtection:      item.ToSecurityProtection(),
		References:              references,
		Summary:                 item.FirstCVEDescription(lang),
	}

	return entry, nil
}

func (item NvdCveItem) ToSecurityProtection() string {
	const (
		all   = "ALLOWS_ADMIN_ACCESS"
		user  = "ALLOWS_USER_ACCESS"
		other = "ALLOWS_OTHER_ACCESS"
		none  = ""
	)

	if item.Impact.BaseMetricV2.ObtainAllPrivilege {
		return all
	}
	if item.Impact.BaseMetricV2.ObtainUserPrivilege {
		return user
	}
	if item.Impact.BaseMetricV2.ObtainOtherPrivilege {
		return other
	}

	return none
}

func (item NvdCveItem) FirstCVEDescription(lang string) string {
	for _, descrip := range item.Cve.Description.DescriptionData {
		if descrip.Lang == lang {
			return descrip.Value
		}
	}
	return ""
}

func ReferenceTagsToReferenceType(tags []string) string {
	// NOTE: not an exact mapping, some are guesses
	const (
		jsonPatch   = "Patch"
		xmlPATCH    = "PATCH"
		jsonVA      = "Vendor Advisory"
		xmlVA       = "VENDOR_ADVISORY"
		jsonTPA     = "Third Party Advisory"
		xmlTPA      = "THIRD_PARTY_ADVISORY"
		jsonSS      = "Signature Source"
		xmlSS       = "SIGNATURE_SOURCE"
		jsonMP      = "Mitigation"
		xmlMP       = "MITIGATION_PROCEDURE"
		jsonTCD     = "Release Notes"
		xmlTCD      = "TOOL_CONFIGURATION_DESCRIPTION"
		defaultType = "UNKNOWN"
	)

	for _, t := range tags {
		if strings.EqualFold(t, jsonPatch) {
			return xmlPATCH
		}
		if strings.EqualFold(t, jsonVA) {
			return xmlVA
		}
		if strings.EqualFold(t, jsonTPA) {
			return xmlTPA
		}
		if strings.EqualFold(t, jsonSS) {
			return xmlSS
		}
		if strings.EqualFold(t, jsonMP) {
			return xmlMP
		}
		if strings.EqualFold(t, jsonTCD) {
			return xmlTCD
		}
	}

	return defaultType
}

type NvdCpeMatch struct {
	Vulnerable            bool         `json:"vulnerable"`
	Cpe23URI              string       `json:"cpe23Uri" mapstructure:"cpe23Uri"`
	VersionStartIncluding string       `json:"versionStartIncluding"`
	VersionStartExcluding string       `json:"versionStartExcluding"`
	VersionEndIncluding   string       `json:"versionEndIncluding"`
	VersionEndExcluding   string       `json:"versionEndExcluding"`
	Cpename               []NvdCpeName `json:"cpe_name" mapstructure:"cpe_name"`
}

type NvdCpeName struct {
	Cpe23URI string `json:"cpe23Uri" mapstructure:"cpe23Uri"`
}

func (n NvdCpeMatch) ToHash() string {
	name := fmt.Sprintf("%s|%s|%s|%s|%s", n.Cpe23URI, n.VersionStartIncluding, n.VersionStartExcluding, n.VersionEndIncluding, n.VersionEndExcluding)
	guid := uuid.NewV5(uuid.NamespaceOID, name)
	return guid.String()
}
